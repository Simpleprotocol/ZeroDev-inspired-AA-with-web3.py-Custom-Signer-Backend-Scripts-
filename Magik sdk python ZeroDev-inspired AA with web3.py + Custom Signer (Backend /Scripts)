# magic_aa_example.py
"""
Magic + ERC-4337 Account Abstraction in Python (backend/script usage)
Requirements:
    pip install magic-admin web3 eth-account requests

Limitations: This is server-side oriented.
Magic Python SDK doesn't provide browser-like signer → use with caution in production.
"""

import os
from typing import Optional
from web3 import Web3
from eth_account import Account
from eth_account.signers.local import LocalAccount
from magic_admin import MagicAdmin

# ─── CONFIG ────────────────────────────────────────────────────────────────
MAGIC_SECRET_KEY = os.getenv("MAGIC_SECRET_KEY")           # from Magic dashboard - server-side secret
ZERODEV_PROJECT_ID = os.getenv("ZERODEV_PROJECT_ID")       # Optional - for sponsored bundler
BUNDLER_URL = "https://api.zerodev.app/bundler/v1"         # or Pimlico, Alchemy, etc.
CHAIN_RPC = "https://rpc.sepolia.org"                      # Sepolia testnet

w3 = Web3(Web3.HTTPProvider(CHAIN_RPC))

magic = MagicAdmin(MAGIC_SECRET_KEY)

class MagicSmartAccount:
    """Very simplified ERC-4337 style wrapper for Magic user + AA in Python"""
    
    def __init__(self, did_token: str):
        # Verify Magic DID token (comes from frontend after login)
        self.did_token = did_token
        self.user = magic.users.get_metadata_by_did(did_token)
        
        if not self.user:
            raise ValueError("Invalid DID token")
            
        print(f"Logged in as: {self.user['email']} | Public address: {self.user['public_address']}")
        
        # In real apps you would:
        # 1. Use deterministic key derivation from Magic (not exposed in Python SDK)
        # 2. Or bridge to a backend signer controlled by the user
        # Here we simulate with a dummy local account - REPLACE IN PRODUCTION!
        self.signer: LocalAccount = Account.from_key(
            "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"  # test key - NEVER use in prod!
        )
        
        self.smart_account_address = self._compute_smart_account_address()
    
    def _compute_smart_account_address(self) -> str:
        """Dummy - in reality use ZeroDev Kernel / Alchemy LightAccount factory address computation"""
        # For real implementation see: https://docs.zerodev.app/ or alchemy aa python examples
        return self.signer.address  # ← placeholder
    
    def send_user_operation(self, target: str, data: str, value: int = 0) -> Optional[str]:
        """Simplified simulation of sending UserOperation (real impl needs proper bundler client)"""
        print(f"Would send UserOp → Target: {target}")
        print(f"Data: {data}")
        print(f"Value: {value}")
        
        # Real implementation example (requires extra libs like 'erc4337' or custom):
        # from erc4337.client import BundlerClient
        # bundler = BundlerClient(BUNDLER_URL)
        # uo = {"sender": self.smart_account_address, ...}
        # return bundler.send_user_operation(uo)
        
        return "0xsimulated_user_op_hash"
    
    def get_balance(self) -> int:
        return w3.eth.get_balance(self.smart_account_address)


# ─── USAGE EXAMPLE ─────────────────────────────────────────────────────────
if __name__ == "__main__":
    # Assume you received DID token from frontend after Magic login
    example_did_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."  # ← get from frontend
    
    try:
        account = MagicSmartAccount(example_did_token)
        
        print(f"Smart Account Address: {account.smart_account_address}")
        print(f"Balance: {w3.from_wei(account.get_balance(), 'ether')} ETH")
        
        # Example: call a contract (e.g. mint NFT)
        tx_data = "0x1249c58d0000000000000000000000000000000000000000000000000000000000000001"  # dummy calldata
        user_op_hash = account.send_user_operation(
            target="0xYourContractAddressHere",
            data=tx_data,
            value=0
        )
        print(f"UserOp hash: {user_op_hash}")
        
    except Exception as e:
        print(f"Error: {e}")
